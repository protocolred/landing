<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta
            name="viewport"
            content="width=device-width, height=device-height, initial-scale=1, viewport-fit=cover, user-scalable=no, minimal-ui"
    />
    <meta name="theme-color" content="#000" />
    <link rel="icon" href="icons/favicon.png" type="image/png" sizes="32x32" />
    <link rel="apple-touch-icon" href="icons/favicon.png" sizes="180x180" />
    <link rel="stylesheet" href="styles/styles.css" />
    <title>Protocol</title>
</head>
<body>
<div class="main">
    <div class="desktop">
	        <header class="header">
	            <button class="logo logo-button" type="button">RED</button>
	            <a href="#" data-target="block-main">ABOUT</a>
	            <a href="#demo" data-target="demo">DEMO</a>
	            <a href="#app" data-target="app">APP</a>
	        </header>

	        <div class="page-bg" aria-hidden="true">
	            <div class="page-bg__layer page-bg__layer--stars" data-parallax-layer></div>
	            <div class="page-bg__layer page-bg__layer--nebula" data-parallax-layer></div>
	            <div class="page-bg__layer page-bg__layer--grid" data-parallax-layer></div>
	            <div class="horizon-bg" id="horizon-bg"></div>
	            <div class="page-bg__overlay"></div>
	            <div class="page-bg__grain"></div>
	        </div>

	        <div id="list">
		            <section class="block" id="block-main">
		                <div class="block-text">
	                    <div class="main-text" id="protocol-text">
	                        <div class="main-text-row" data-text="PROTOCOL">
	                            <div class="glitch-letter">P</div>
                            <div class="glitch-letter">R</div>
                            <div class="glitch-letter">O</div>
                            <div class="glitch-letter">T</div>
                            <div class="glitch-letter">O</div>
                            <div class="glitch-letter">C</div>
                            <div class="glitch-letter">O</div>
                            <div class="glitch-letter">L</div>
                        </div>
                    </div>
                </div>

                <div class="social">
                    <div><a target="_blank" href="https://twitter.com/protocolredapp">TWITTER</a></div>
                    <div><a target="_blank" href="https://instagram.com/protocolredapp">INSTAGRAM</a></div>
                    <div><a target="_blank" href="privacy.html">PRIVACY</a></div>
                </div>

                <div class="store" id="store-main">
                    <div id="ios-store">
                        <a href="https://testflight.apple.com/join/5z8kZqg6" target="_blank">
                            <img src="images/buttons/apple-store-badge.svg" alt="Download on the App Store"/>
                        </a>
                    </div>

                    <div id="android-store">
                        <a href="https://play.google.com/store/apps/details?id=space.mpak.protocol" target="_blank">
                            <img src="images/buttons/google-play-badge.png" alt="Get it on Google Play"/>
                        </a>
                    </div>
                </div>
            </section>

            <section class="block block-create" id="demo">
                <div class="block-create-copy">
                    <div class="protocol-lines">
                        <div class="protocol-line">This is a protocol, not a game</div>
                        <div class="protocol-line">Consent recorded, behavior measured</div>
                        <div class="protocol-line protocol-joke" id="protocol-joke"></div>
                    </div>
                </div>

<!--                <div class="phone">-->
<!--                    <img src="images/phone/role.png" alt="Character preview"/>-->
<!--                    <div class="phone-title">Nova Synthia</div>-->

<!--                    <div class="phone-stats">-->
<!--                        <div class="luck">-->
<!--                            <div class="box"></div><div class="box"></div><div class="box"></div><div class="box"></div>-->
<!--                        </div>-->
<!--                        <div class="red">-->
<!--                            <div class="box"></div><div class="box"></div><div class="box"></div>-->
<!--                        </div>-->
<!--                        <div class="blue">-->
<!--                            <div class="box"></div><div class="box"></div><div class="box"></div><div class="box"></div><div class="box"></div><div class="box"></div><div class="box"></div>-->
<!--                        </div>-->
<!--                    </div>-->

<!--                    <div class="phone-stats-info">-->
<!--                        <div>LUCK</div>-->
<!--                        <div>STRENGTH</div>-->
<!--                        <div>INTELLECT</div>-->
<!--                    </div>-->
<!--                </div>-->
            </section>

            <section class="block" id="app">
                <div class="app-hero" id="bottom-hero"></div>
                <div class="app-sub" id="bottom-sub"></div>

                <div class="store store-bottom">
                    <div id="ios-store">
                        <a href="https://testflight.apple.com/join/5z8kZqg6" target="_blank">
                            <img src="images/buttons/apple-store-badge.svg" alt="Download on the App Store"/>
                        </a>
                    </div>

                    <div id="android-store">
                        <a href="https://play.google.com/store/apps/details?id=space.mpak.protocol" target="_blank">
                            <img src="images/buttons/google-play-badge.png" alt="Get it on Google Play"/>
                        </a>
                    </div>
                </div>
            </section>
        </div>

        <!--<footer class="footer">Made for the App â€” quiet, private, connected.</footer>-->
    </div>
</div>
	<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js" defer></script>
	<script src="scripts/page-bg-parallax.js" defer></script>
	<script src="scripts/horizon-bg.js" defer></script>
	<script>
	    (function () {
	        const letters = document.querySelectorAll('.glitch-letter')
	        const protocolText = document.getElementById('protocol-text')
	        const characters = '2470ABCDEFGHIJKLNOPQRSTUVXYZ'

        const runTextEffect = () => {
            let tick = 0
            const maxTicks = 18
            const settleOffsets = Array.from({length: letters.length}, (_, i) => i + 4)

            const timer = setInterval(() => {
                tick++
                letters.forEach((letter, index) => {
                    const finalChar = letter.dataset.final || letter.textContent
                    if (tick < settleOffsets[index]) {
                        const randomIndex = Math.floor(Math.random() * characters.length)
                        letter.textContent = characters[randomIndex]
                    } else {
                        letter.textContent = finalChar
                    }
                })

                if (tick > maxTicks + letters.length) {
                    clearInterval(timer)
                }
            }, 80)
        }

        letters.forEach(letter => {
            letter.dataset.final = letter.textContent
        })

        runTextEffect()
        if (protocolText) {
            protocolText.addEventListener('click', runTextEffect)
        }

        const headerLinks = Array.from(document.querySelectorAll('.header a[data-target]'))
        const sections = headerLinks
            .map(link => document.getElementById(link.getAttribute('data-target')))
            .filter(Boolean)

        const setActive = (id) => {
            headerLinks.forEach(link => {
                const isActive = link.getAttribute('data-target') === id
                link.classList.toggle('active', isActive)
            })
        }

        const observer = new IntersectionObserver(
            (entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        setActive(entry.target.id)
                    }
                })
            },
            {root: null, threshold: 0.6}
        )

        sections.forEach(section => observer.observe(section))

        const initActive = () => {
            const hashId = window.location.hash?.replace('#', '')
            if (hashId === 'block-main') {
                history.replaceState(null, '', window.location.pathname + window.location.search)
                setActive('block-main')
                return
            }
            if (hashId) {
                setActive(hashId)
                return
            }
            if (sections[0]) {
                setActive(sections[0].id)
            }
        }

        requestAnimationFrame(initActive)
        window.addEventListener('load', initActive)

        headerLinks.forEach(link => {
            link.addEventListener('click', (event) => {
                if (event.defaultPrevented) return
                if (event.button !== 0) return
                if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) return

                const targetId = link.getAttribute('data-target')
                if (!targetId) return
                if (targetId !== 'block-main') return

                event.preventDefault()
                history.replaceState(null, '', window.location.pathname + window.location.search)
                const el = document.getElementById(targetId)
                if (el) el.scrollIntoView({behavior: 'smooth', block: 'start'})
                setActive(targetId)
            })
        })

        const storeMain = document.getElementById('store-main')
        const toggleStoreOnScroll = () => {
            if (!storeMain) return
            const isAtTop = window.scrollY <= 1
            storeMain.classList.toggle('is-hidden', !isAtTop)
        }

        window.addEventListener('scroll', toggleStoreOnScroll, {passive: true})
        toggleStoreOnScroll()

        const jokeEl = document.getElementById('protocol-joke')
        const setRandomJoke = (jokes) => {
            if (!jokeEl || !Array.isArray(jokes) || jokes.length === 0) return
            const randomIndex = Math.floor(Math.random() * jokes.length)
            jokeEl.textContent = jokes[randomIndex]
        }

        const loadJokes = async () => {
            try {
                const response = await fetch('texts/jokes.json', {cache: 'no-store'})
                if (!response.ok) throw new Error(`Failed to load jokes: ${response.status}`)
                const jokes = await response.json()
                setRandomJoke(jokes)
                if (jokeEl) jokeEl.addEventListener('click', () => setRandomJoke(jokes))
            } catch {
                setRandomJoke([
                    'No plot armor.',
                    'No badges. Just logs.',
                    'Deviation noted.',
                    'We saw that.'
                ])
            }
        }

        loadJokes()

        const bottomHeroEl = document.getElementById('bottom-hero')
        const bottomSubEl = document.getElementById('bottom-sub')

        const SCRAMBLE_CHARACTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
        const scrambleTokens = new WeakMap()

        const getRandomChar = () => {
            const randomIndex = Math.floor(Math.random() * SCRAMBLE_CHARACTERS.length)
            return SCRAMBLE_CHARACTERS[randomIndex]
        }

        const animateScrambleText = (el, fromText, toText, durationMs = 500) => {
            if (!el) return Promise.resolve()

            const from = typeof fromText === 'string' ? fromText : String(fromText ?? '')
            const to = typeof toText === 'string' ? toText : String(toText ?? '')
            if (from === to) {
                el.textContent = to
                return Promise.resolve()
            }

            const token = (scrambleTokens.get(el) || 0) + 1
            scrambleTokens.set(el, token)

            const maxLen = Math.max(from.length, to.length)
            const toPadded = to.padEnd(maxLen, ' ')

            const order = Array.from({length: maxLen}, (_, i) => i)
            for (let i = order.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1))
                ;[order[i], order[j]] = [order[j], order[i]]
            }

            const settledMask = Array.from({length: maxLen}, () => false)
            let nextToSettle = 0
            const start = performance.now()

            return new Promise(resolve => {
                const frame = (now) => {
                    if (scrambleTokens.get(el) !== token) return resolve()

                    const progress = Math.min(1, (now - start) / durationMs)
                    const desiredSettled = Math.floor(progress * maxLen)
                    while (nextToSettle < desiredSettled) {
                        const idx = order[nextToSettle]
                        settledMask[idx] = true
                        nextToSettle++
                    }

                    let out = ''
                    for (let i = 0; i < maxLen; i++) {
                        const targetChar = toPadded[i]
                        if (settledMask[i]) {
                            out += targetChar
                            continue
                        }
                        if (targetChar === ' ' || targetChar === '\n' || targetChar === '\t') {
                            out += targetChar
                            continue
                        }
                        out += getRandomChar()
                    }

                    el.textContent = out.replace(/\s+$/, '')

                    if (progress < 1) {
                        requestAnimationFrame(frame)
                        return
                    }

                    el.textContent = to
                    resolve()
                }

                requestAnimationFrame(frame)
            })
        }

        const renderParagraphs = (el, paragraphs) => {
            if (!el) return
            el.innerHTML = ''
            paragraphs.forEach(text => {
                const p = document.createElement('p')
                p.textContent = text
                el.appendChild(p)
            })
        }

        const applyBottomBlockCopy = (copy) => {
            if (!copy || typeof copy !== 'object') return
            if (bottomHeroEl && typeof copy.hero === 'string' && copy.hero.trim()) {
                bottomHeroEl.textContent = copy.hero
            }
            if (bottomSubEl && Array.isArray(copy.paragraphs) && copy.paragraphs.length > 0) {
                renderParagraphs(bottomSubEl, copy.paragraphs)
            }
        }

        const getRandomItem = (items) => {
            if (!Array.isArray(items) || items.length === 0) return null
            return items[Math.floor(Math.random() * items.length)]
        }

        let bottomCopies = []
        let currentBottomCopy = null
        let bottomCopiesLoading = null

        const fetchBottomCopies = async () => {
            const response = await fetch('texts/bottom-block.variants.json', {cache: 'no-store'})
            if (!response.ok) throw new Error(`Failed to load bottom variants: ${response.status}`)
            const variants = await response.json()
            return Object.values(variants).filter(v => v && typeof v === 'object')
        }

        const ensureBottomCopiesLoaded = async () => {
            if (Array.isArray(bottomCopies) && bottomCopies.length > 0) return bottomCopies
            if (bottomCopiesLoading) return bottomCopiesLoading

            bottomCopiesLoading = fetchBottomCopies()
                .then((copies) => {
                    bottomCopies = copies
                    return copies
                })
                .catch(() => {
                    bottomCopies = []
                    return bottomCopies
                })
                .finally(() => {
                    bottomCopiesLoading = null
                })

            return bottomCopiesLoading
        }

        const pickNextBottomCopy = () => {
            if (!Array.isArray(bottomCopies) || bottomCopies.length === 0) return null
            if (bottomCopies.length === 1) return bottomCopies[0]

            let next = getRandomItem(bottomCopies)
            let guard = 0
            while (next === currentBottomCopy && guard < 10) {
                next = getRandomItem(bottomCopies)
                guard++
            }
            return next
        }

        const transitionBottomBlockCopy = async (copy) => {
            if (!copy || typeof copy !== 'object') return

            const heroTo = typeof copy.hero === 'string' ? copy.hero : ''
            const paragraphsTo = Array.isArray(copy.paragraphs) ? copy.paragraphs : []

            const heroFrom = bottomHeroEl?.textContent ?? ''
            const jobs = []
            if (bottomHeroEl) {
                jobs.push(animateScrambleText(bottomHeroEl, heroFrom, heroTo, 500))
            }

            if (bottomSubEl) {
                const existing = Array.from(bottomSubEl.querySelectorAll('p'))

                while (existing.length < paragraphsTo.length) {
                    const p = document.createElement('p')
                    bottomSubEl.appendChild(p)
                    existing.push(p)
                }

                for (let i = 0; i < existing.length; i++) {
                    const el = existing[i]
                    const from = el.textContent ?? ''
                    const to = paragraphsTo[i] ?? ''
                    jobs.push(
                        animateScrambleText(el, from, to, 500).then(() => {
                            if (i >= paragraphsTo.length) el.remove()
                        })
                    )
                }
            }

            await Promise.all(jobs)
            currentBottomCopy = copy
        }

        const loadBottomBlockCopy = async () => {
            try {
                await ensureBottomCopiesLoaded()
                const randomCopy = pickNextBottomCopy()
                if (randomCopy) {
                    currentBottomCopy = randomCopy
                    applyBottomBlockCopy(randomCopy)
                }
            } catch {
                // Keep the HTML fallback.
            }
        }

	        loadBottomBlockCopy()

	        const bottomBlockEl = document.getElementById('app')
	        const onBottomBlockActivate = (event) => {
	            if (!bottomBlockEl) return
	            if (event?.target?.closest?.('a')) return
	            ensureBottomCopiesLoaded().then(() => {
	                const next = pickNextBottomCopy()
	                if (!next) return
	                transitionBottomBlockCopy(next)
	            })
	        }

	        if (bottomBlockEl) {
	            bottomBlockEl.addEventListener('click', onBottomBlockActivate)
	            bottomBlockEl.addEventListener('keydown', (event) => {
	                if (event.key !== 'Enter' && event.key !== ' ') return
	                if (event.target?.closest?.('a')) return
	                event.preventDefault()
	                onBottomBlockActivate(event)
	            })
	            if (!bottomBlockEl.hasAttribute('tabindex')) bottomBlockEl.tabIndex = 0
	        }

	        const redButton = document.querySelector('.header .logo-button')
	        const onRedClick = () => {
	        }
	        if (redButton) {
	            redButton.setAttribute('aria-pressed', 'false')

	            const setExpanded = (isExpanded) => {
	                redButton.classList.toggle('is-expanded', isExpanded)
	                redButton.setAttribute('aria-pressed', String(isExpanded))
	            }

	            const collapseViaZero = () => {
	                redButton.classList.add('is-collapsing')
	                setExpanded(false)

	                let cleaned = false
	                const cleanup = () => {
	                    if (cleaned) return
	                    cleaned = true
	                    redButton.classList.remove('is-collapsing')
	                }

	                const onTransitionEnd = (event) => {
	                    if (event.propertyName !== 'transform') return
	                    cleanup()
	                }

	                redButton.addEventListener('transitionend', onTransitionEnd, {once: true})
	                setTimeout(cleanup, 260)
	            }

	            redButton.addEventListener('click', () => {
	                const isExpanded = redButton.classList.contains('is-expanded')
	                if (isExpanded) {
	                    collapseViaZero()
	                } else {
	                    redButton.classList.remove('is-collapsing')
	                    setExpanded(true)
	                }
	                onRedClick()
	            })
	        }
	    })()
	</script>
</body>
</html>
